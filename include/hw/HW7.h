#pragma once

#include "tools/Algorithms.h"
#include "tools/Environment.h"
#include "tools/Path.h"
#include "tools/Graph.h"

#include <tuple>

namespace amp {

/// @brief Derive this class and implement your algorithm in the `plan` method. 
class PRM : public PointMotionPlanner2D {
    public:
        /// @brief Solve a motion planning problem. Create a derived class and override this method
        //virtual amp::Path2D plan(const amp::Problem2D& problem) = 0;

        virtual ~PRM() {}
};

/// @brief Derive this class and implement your algorithm in the `plan` method. 
class GoalBiasRRT : public PointMotionPlanner2D {
    public:
        /// @brief Solve a motion planning problem. Create a derived class and override this method
        //virtual amp::Path2D plan(const amp::Problem2D& problem) = 0;

        virtual ~GoalBiasRRT() {}
};

class HW7 {
    public:
        /// @brief Checks the path generated by your motion planner against the problem
        /// @param path Path generated by your motion planner
        /// @param prob Problem that path was generated on
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool check(const amp::Path2D& path, const amp::Problem2D& prob, bool verbose = true);

        /// @brief Checks the path generated by your motion planner against the problem
        /// @param path Path generated by your motion planner
        /// @param prob Problem that path was generated on
        /// @param verbose Output logs displaying result
        /// @param collision_points Gather collision points found along the path
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool check(const amp::Path2D& path, const amp::Problem2D& prob, std::vector<Eigen::Vector2d>& collision_points, bool verbose = true);

        /// @brief Generates a random problem, runs the algorithm, then check the validity of the returned solution.
        /// Similar to what the benchmarker in `grade()` will do
        /// @param algo Your implemented algorithm
        /// @param seed Seed the random generator. If the seed is `0u`, no seed is used (random)
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool generateAndCheck(amp::PointMotionPlanner2D& algo, bool verbose = true, uint32_t seed = 0u);

        /// @brief Generates a random problem, runs the algorithm, then check the validity of the returned solution.
        /// Similar to what the benchmarker in `grade()` will do
        /// @param algo Your implemented algorithm
        /// @param path Return the path generated by your algorithm
        /// @param prob Return the randomly generated problem used
        /// @param seed Seed the random generator. If the seed is `0u`, no seed is used (random)
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool generateAndCheck(amp::PointMotionPlanner2D& algo, amp::Path2D& path, amp::Problem2D& prob, bool verbose = true, uint32_t seed = 0u);

        /// @brief Generates a random problem, runs the algorithm, then check the validity of the returned solution.
        /// Similar to what the benchmarker in `grade()` will do
        /// @param algo Your implemented algorithm
        /// @param path Return the path generated by your algorithm
        /// @param prob Return the randomly generated problem used
        /// @param collision_points Gather collision points found along the path
        /// @param seed Seed the random generator. If the seed is `0u`, no seed is used (random)
        /// @param verbose Output logs displaying result
        /// @return `true` if path is a valid solution, `false` otherwise
        static bool generateAndCheck(amp::PointMotionPlanner2D& algo, amp::Path2D& path, amp::Problem2D& prob, std::vector<Eigen::Vector2d>& collision_points, bool verbose = true, uint32_t seed = 0u);

        // Coming soon!
        //static int grade(PRM& prm_algo, GoalBiasRRT& rrt_algo, const std::string& email, int argc, char** argv);
};

#define AMP_HW7_ALIAS "hw7"
#define AMP_HW7_PACKAGE_NAME "hw7_report_card"
}

#include "public/HW7_impl.h"